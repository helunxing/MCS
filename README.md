# 分布式缓存

学习[《分布式缓存》](https://book.douban.com/subject/30456816/)一书的实践记录和笔记。 

[书中代码](https://github.com/stuarthu/go-implement-your-cache-server)

### 基本实现

#### c1 基于http/rest的内存缓存

由于http解析，性能是redis的约四分之一

#### c2 基于tcp的内存缓存

性能有明显提升

#### c3 数据持久化

rocksdb：字节流形式键值对持久化。压缩系数调优。

cgo调用capi

rocksdb可以虚拟内存，还可以重启恢复。但语言转化有一定开销

### 单点性能提升

#### c4 pipeline

不等待回复，连续发多个请求

响应的接受通常由其他协程负责

#### c5 rocksdb批量写入

多个set指令合并成一个，连续写入磁盘。无法得知写入失败，没有实时一致性。

channel类似polling。允许等待多事件同时发生

timer. Timer含一个成员chan Time C，触发后会发送time. Time结构体。重置时要先用stop确认，触发要先取出C中第一个

#### c6 异步操作提升读性能

服务端使用channel保证异步返回顺序

异步操作支出：channel和协程。rocksdb操作时间较慢，客户端请求密度较高。

本章功能使用channel实现，好处在于易读易实现地完成异步取结果的功能

传出的channel在何处关闭？不会阻塞消费者无需手动关闭

### 服务集群

#### c7 分布式缓存

本书实现同构集群，之间通过gossip协议更新状态。

一致性散列：将节点映射到散列环上，负责一定区域的服务。使用一个节点由有多个虚拟节点的方式方式不均衡

当前无法保证一致性

#### c8 节点再平衡

添加节点时，将老节点的部分数据迁移到新结点上。

inMemoryScanner未看懂

#### c9 缓存生存时间

#### 结尾
资源总量越大，失效概率越高。实际获取速度越快，缓存边界效用越低。遇到性能问题要具体分析。
